# Markdown File Annotation

Plannotator can annotate any markdown file, not just plans generated by `ExitPlanMode`. This lets users open a markdown document in the annotation UI, mark it up with structured feedback, and send that feedback back to the agent session.

## How to use it

### Slash command (inside a Claude Code or OpenCode session)

```
/plannotator-annotate path/to/file.md
```

The agent runs `plannotator annotate <file>` under the hood. The annotation UI opens in the browser. When you submit feedback, it's returned to the agent as structured output so it can act on your annotations.

### Standalone (outside an agent session)

```bash
bun apps/hook/server/index.ts annotate path/to/file.md
```

This starts a local server, opens the browser, and blocks until you submit feedback. The formatted feedback is printed to stdout.

## How it works

### 1. CLI reads the file

The `annotate` subcommand in `apps/hook/server/index.ts` resolves the file path, reads its contents as text, and passes the markdown string to `startAnnotateServer()`.

```
plannotator annotate README.md
        |
        v
reads file -> markdown string
        |
        v
startAnnotateServer({ markdown, filePath, ... })
```

### 2. Server starts

`packages/server/annotate.ts` starts a Bun HTTP server on a random port (or a fixed port in remote mode). It serves:

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/api/plan` | GET | Returns `{ plan, mode: "annotate", filePath, ... }` |
| `/api/feedback` | POST | Receives the exported annotations |
| `/api/image` | GET | Serves local images by path |
| `/api/upload` | POST | Saves pasted/uploaded images to `/tmp/plannotator/` |
| `*` | GET | Serves the single-file HTML app |

The server reuses the same plan editor HTML (`apps/hook/dist/index.html`). No separate build target is needed. The `/api/plan` response includes `mode: "annotate"` to tell the frontend it's in annotation mode.

### 3. Frontend detects annotate mode

`packages/editor/App.tsx` fetches `/api/plan` on load. When it sees `mode: "annotate"`, it sets `annotateMode = true`, which changes the UI:

- The "Approve" button is hidden (there's nothing to approve)
- The "Send Feedback" button becomes "Send Annotations"
- `Cmd+Enter` sends annotations instead of approving
- The submitted overlay says "Annotations Sent" instead of "Plan Approved"

Everything else works the same as plan review: the markdown is parsed into blocks, rendered by the `<Viewer>` component, and annotated with `web-highlighter`.

### 4. User annotates the document

The annotation tools are identical to plan review:

| Mode | Behavior |
|------|----------|
| **Select** | Select text, then choose an annotation type from the toolbar |
| **Redline** | Select text to instantly mark it for deletion |
| **Comment** | Select text to jump straight to adding a comment |

Annotation types:

- **Deletion** — "Remove this"
- **Replacement** — "Change this to..."
- **Comment** — "Feedback on this..."
- **Insertion** — "Add this after..."
- **Global comment** — General feedback not tied to specific text

Users can also paste or upload images and attach them to annotations.

### 5. Feedback is exported and sent

When the user clicks "Send Annotations" (or presses `Cmd+Enter`), the frontend:

1. Calls `exportAnnotations(blocks, annotations, globalAttachments)` from `packages/ui/utils/parser.ts` to generate a structured markdown summary
2. POSTs the result to `/api/feedback`

The export format looks like:

```markdown
# Plan Feedback

I've reviewed this plan and have 2 pieces of feedback:

## 1. Remove this
```
the selected text
```
> I don't want this in the plan.

## 2. Feedback on: "some highlighted text"
> This needs more detail about error handling.

---
```

### 6. Server returns feedback to the caller

The `/api/feedback` endpoint resolves a promise that the CLI is awaiting. The server shuts down, and the formatted feedback string is printed to stdout. When invoked via the slash command, Claude Code captures this output and the agent sees a prompt like:

```
## Markdown Annotations

<the exported feedback>

## Your task

Address the annotation feedback above. The user has reviewed the markdown file
and provided specific annotations and comments.
```

The agent then acts on each annotation.

## Architecture

```
User runs /plannotator-annotate README.md
        |
        v
CLI reads README.md as text
        |
        v
startAnnotateServer() — Bun server on random port
        |
        v
Browser opens, loads single-file HTML app
        |
        v
/api/plan returns { plan: markdown, mode: "annotate" }
        |
        v
Viewer renders markdown, web-highlighter enables annotation
        |
        v
User annotates → Send Annotations
        |
        v
POST /api/feedback with exported feedback string
        |
        v
Server resolves promise, prints feedback to stdout, exits
        |
        v
Agent receives structured feedback, acts on it
```

## Key files

| File | Role |
|------|------|
| `apps/hook/server/index.ts` | CLI entry point, `annotate` subcommand |
| `packages/server/annotate.ts` | Annotate server implementation |
| `packages/editor/App.tsx` | Frontend — detects `annotateMode`, adjusts UI |
| `packages/ui/components/Viewer.tsx` | Markdown renderer + web-highlighter annotation |
| `packages/ui/utils/parser.ts` | `parseMarkdownToBlocks()` and `exportAnnotations()` |
| `apps/hook/commands/plannotator-annotate.md` | Claude Code slash command definition |
| `apps/opencode-plugin/commands/plannotator-annotate.md` | OpenCode slash command definition |

## Environment variables

The annotate server respects the same environment variables as plan review:

| Variable | Description |
|----------|-------------|
| `PLANNOTATOR_REMOTE` | Set to `1` for remote/SSH mode (fixed port, no browser open) |
| `PLANNOTATOR_PORT` | Fixed port (default: random locally, `19432` for remote) |
| `PLANNOTATOR_BROWSER` | Custom browser to open the UI in |
